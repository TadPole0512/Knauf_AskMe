아래는 우리 회사의 실제 개발 및 배포 프로세스와 겪고 있는 문제 사례입니다.

---
[현재 프로세스]
- GitHub Desktop 프로그램을 사용해 소스 이력/협업을 관리하고 있습니다.
- 개발은 각자 feature 브랜치에서 진행, develop 브랜치로 병합(merge) 후 테스트 서버에 반영합니다.
- 테스트 서버에는 지금까지 개발된 모든 기능이 반영되어, 클라이언트가 테스트합니다.
- 운영 서버에는 클라이언트가 “운영 반영”을 요청한 기능만 따로 추려서, 필요 없는 소스는 삭제 후 수동으로 배포합니다.
- 자동화 배포, 서버 Git 연동, SSH/토큰 인증 등은 보안 정책상 모두 불가합니다.
- war 파일을 직접 빌드해서, 서버에 원격접속(VDI) 후 수동 업로드 방식만 사용 가능합니다.

[실제 겪은 문제/불편]
- 테스트 서버에 모든 개발 기능이 섞여 올라가, 운영에는 반영되지 않아야 할 소스(기능)까지 섞여 들어가 서비스 오작동 및 민원이 발생했습니다.
- 운영에 일부 기능만 반영하려다 소스 삭제/추리기 과정에서 실수 발생.
- 브랜치 병합(Merge), 롤백(복구), 협업 충돌 관리도 어렵습니다.


[추가 사항]

1. 운영/테스트 서버의 구조
   운영 서버와 테스트 서버는 각각 어떤 방식으로 관리되나요? (예: 물리적으로 다른 서버인지, 같은 Tomcat 환경 내에서 포트만 다른지 등)
   => 같은 서버에 DEV 톰캣과 REAL 톰캣으로 따로 톰캣서버가 존재.해당 톰캣 webapp 폴더 밑에 war 파일을 붙여넣고 서비스. 아파치 웹서버와 연동. 각각의 도메인으로 접속.

2. 현재 배포 방식에서의 워크플로
   WAR 파일을 빌드해서 수동 업로드한다고 하셨는데, 이 때 정확히 어떤 디렉토리에 배포하나요?
   => 개발 서버는 DEV 톰캣 폴더 하위의 webapp 폴도, 운영 서버는 REAL 톰캣 폴더 하위 webapp 폴더에 배포

  테스트 서버에는 어떤 기준으로 반영되며, 배포 시점은 누가/언제 결정하나요?
  => 개발자가 개발이 완료된 이후 클라이언트에게 테스트 요청하기 전에 개발 서버에서 war파일을 만들어 복사 붙여넣기함.

3. 현재 브랜치 전략 관련
  "운영에 반영해야 할 기능만 따로 추리는" 작업은 어떤 식으로 하고 있나요? 예: develop에서 작업된 기능 중 일부만 main에 cherry-pick 하는 식인지, 아니면 수동 복붙?
  => 개발서버에서 개발된 소스만 관리. 운영 및 테스트에는 개발자기 직접 수동으로 복붙.

4. 협업 인원
   몇 명이 동시에 개발에 참여하고 있는지, GitHub 사용 경험은 모두 있는지 알고 싶어요.
   => 2명이 참여. GitHub에 대한 경험은 없음.

4. GitHub Desktop 사용 범위
   오직 GitHub Desktop만 사용하고 있는지, CLI나 VSCode Git 플러그인은 아예 사용하지 않는 건가요?
   => 오직 GitHub만 사용. STS4에서 작업한 다음 GitHub Desktop 프로그램을 실행하여 수정 및 추가한 소스를 push함.

---

**이런 상황에서,**
1. **GitHub Desktop 프로그램을 기준으로,**  
   개발/테스트/운영 서버 소스 관리와 war 파일 배포 프로세스를  
   **초보자도 이해할 수 있게, 한글로 단계별로 재정의**해 주세요.
2. 특히,
    - GitHub Desktop으로 브랜치/커밋/병합/푸시 등 실무에 바로 쓸 수 있는 상세 매뉴얼(설정/화면 예시 포함)
    - feature/develop/main 브랜치 관리 및 테스트/운영 서버 분리 배포 전략
    - 운영에 일부 기능만 반영 시 소스 혼입/오작동 방지법
    - 협업 중 실수, 충돌, 롤백(복구) 등 문제 해결 전략
    - 자동화/서버 Git/배포툴 없이 GitHub Desktop만으로 안전하게 협업/관리하는 방법
    - (개발환경: STS4.5, Zulu-8, Tomcat 9, Maven, MSSQL, MyBatis, JQGrid 등)
3. 그리고, 현재 프로세스의 **비효율/위험요소**와,  
   **우리 환경에서 실현 가능한 구체적 개선/최적화 절차**도 같이 안내해 주세요.

---

**실제 문제 예시**까지 모두 반영해서,  
**GitHub Desktop을 활용한 “실전 소스/배포 관리 프로세스 개선안”**을  
초보자도 따라할 수 있게,  
**한글로, 단계별로, 예시/팁/가능하면 관련 이미지까지 포함해서** 설명해 주세요.


---------------------------------------------------------------------


# GitHub Desktop 활용 실전 소스/배포 관리 프로세스 개선안

## 🚨 현재 문제점 분석

### 주요 위험요소
1. **소스 혼입 문제**: 테스트 서버에 모든 개발 기능이 섞여 올라가서 운영 반영 시 불필요한 코드까지 포함
2. **수동 복붙의 위험성**: 소스 삭제/추리기 과정에서 실수 발생 가능성
3. **브랜치 관리 미흡**: feature/develop/main 브랜치 전략 부재
4. **협업 충돌 관리 어려움**: 2명이 동시 작업 시 충돌 해결 방법 부족
5. **롤백 어려움**: 문제 발생 시 이전 상태로 복구하기 복잡

---

## 📋 개선된 브랜치 전략 및 프로세스

### 1. 브랜치 구조 재정의
```
main (운영 서버용 - 검증된 기능만)
├── release/v1.0 (운영 배포 준비)
├── develop (테스트 서버용 - 모든 개발 기능)
│   ├── feature/user-management (개발자A)
│   ├── feature/payment-system (개발자B)
│   └── feature/report-module (개발자A)
```

### 2. 각 브랜치 역할 정의
- **main**: 운영 서버에 실제 배포되는 안정된 코드만
- **develop**: 테스트 서버용, 모든 개발 중인 기능들이 통합
- **feature/기능명**: 개별 기능 개발용
- **release/버전**: 운영 배포 전 최종 점검용

---

## 🛠️ GitHub Desktop 실무 매뉴얼

### Step 1: 초기 설정 및 리포지토리 클론

#### 1-1. GitHub Desktop 설치 및 로그인
1. GitHub Desktop 실행
2. `File` → `Options` → `Accounts`에서 GitHub 계정 로그인
3. `Git` 탭에서 사용자 이름과 이메일 설정

#### 1-2. 리포지토리 클론
1. `File` → `Clone repository`
2. GitHub.com 탭에서 프로젝트 선택
3. Local path 설정 (예: `C:\workspace\project`)
4. `Clone` 버튼 클릭

### Step 2: 브랜치 생성 및 전환

#### 2-1. 새 기능 브랜치 생성
1. GitHub Desktop에서 현재 브랜치 확인 (상단 중앙)
2. `develop` 브랜치로 전환
   - 브랜치 드롭다운 클릭
   - `develop` 선택
   - `Switch to develop` 클릭
3. 새 브랜치 생성
   - `Current branch` 드롭다운 → `New branch`
   - 브랜치명 입력: `feature/사용자관리` (한글 가능)
   - `Create branch` 클릭

#### 2-2. 브랜치 전환하기
- 브랜치 드롭다운에서 원하는 브랜치 선택
- `Switch to [브랜치명]` 클릭
- **주의**: 전환 전 현재 작업 내용 커밋 또는 스태시 필요

### Step 3: 일상 개발 워크플로우

#### 3-1. 개발 작업 시작
1. 항상 최신 develop에서 feature 브랜치 생성
2. STS4에서 코딩 작업 진행
3. 작업 완료 후 GitHub Desktop 확인

#### 3-2. 커밋 만들기
1. GitHub Desktop에서 `Changes` 탭 확인
2. 변경된 파일들 확인 (왼쪽 패널)
3. 커밋할 파일 선택 (체크박스)
4. 하단에 커밋 메시지 작성
   - Summary: `사용자 로그인 기능 추가`
   - Description: `- JWT 토큰 기반 인증 구현\n- 로그인 실패 시 에러 처리`
5. `Commit to feature/사용자관리` 버튼 클릭

#### 3-3. 원격 저장소에 푸시
1. 커밋 후 `Push origin` 버튼 클릭
2. 처음 푸시하는 브랜치라면 `Publish branch` 클릭

### Step 4: 브랜치 병합 (Merge) 프로세스

#### 4-1. develop으로 병합 (테스트 서버 반영용)
1. `develop` 브랜치로 전환
2. `Branch` → `Merge into current branch`
3. `feature/사용자관리` 브랜치 선택
4. `Merge feature/사용자관리 into develop` 클릭
5. 병합 후 원격에 푸시

#### 4-2. main으로 병합 (운영 서버 반영용)
1. **중요**: 클라이언트 승인된 기능만 병합
2. `main` 브랜치로 전환
3. 승인된 feature 브랜치들만 선별적으로 병합
4. 또는 `release` 브랜치 생성 후 검증된 기능들만 포함

---

## ⚡ 개선된 배포 프로세스

### 개발 → 테스트 서버 배포

#### 단계 1: 테스트용 WAR 빌드
1. `develop` 브랜치로 전환
2. 최신 코드 Pull
3. STS4에서 프로젝트 우클릭 → `Run As` → `Maven build`
4. Goals: `clean package -DskipTests`
5. 생성된 WAR 파일을 DEV 톰캣 webapp 폴더에 배포

### 테스트 → 운영 서버 배포

#### 단계 1: 운영 반영 브랜치 준비
```bash
# GitHub Desktop에서 수행
1. release/v1.0 브랜치 생성 (main에서)
2. 승인된 feature 브랜치들만 선별적으로 병합
3. 테스트 완료 후 main에 병합
```

#### 단계 2: 운영용 WAR 빌드
1. `main` 브랜치로 전환 (운영 승인 기능만 포함)
2. Clean Build 수행
3. 생성된 WAR 파일을 REAL 톰캣 webapp 폴더에 배포

---

## 🔧 협업 충돌 관리 가이드

### 1. 충돌 예방 방법

#### 작업 시작 전
1. 항상 최신 develop 브랜치에서 feature 브랜치 생성
2. 작업 시작 전 `Fetch origin`으로 최신 상태 확인

#### 정기적 동기화
1. 하루 1회 이상 develop 최신 내용을 feature로 병합
2. 같은 파일 작업 시 팀원과 사전 조율

### 2. 충돌 해결 방법

#### 2-1. 병합 충돌 발생 시
1. GitHub Desktop에서 충돌 파일 표시됨
2. `Open in External Editor` 클릭하여 STS4에서 파일 열기
3. 충돌 마커 확인 및 수정
```java
<<<<<<< HEAD
// 내 코드
String userName = "user";
=======
// 상대방 코드  
String userName = "member";
>>>>>>> feature/other-branch
```
4. 올바른 코드로 수정 후 충돌 마커 제거
5. 파일 저장 후 GitHub Desktop에서 `Mark as resolved`
6. 충돌 해결 커밋 생성

### 3. 롤백 (복구) 전략

#### 3-1. 특정 커밋으로 되돌리기
1. `History` 탭에서 되돌리고 싶은 커밋 선택
2. 우클릭 → `Revert changes in this commit`
3. 자동으로 되돌림 커밋 생성됨

#### 3-2. 브랜치 전체 초기화
1. `Branch` → `Reset current branch`
2. 되돌릴 커밋 선택
3. `Hard` 옵션 선택 (작업 내용 완전 삭제)

---

## 📊 운영 반영 시 소스 혼입 방지법

### 1. 승인된 기능만 운영 반영하는 프로세스

#### 방법 1: Cherry-pick 활용
1. `main` 브랜치에서 `release/v1.0` 브랜치 생성
2. 승인된 feature 브랜치들만 선별적으로 병합
3. 테스트 완료 후 main에 병합

#### 방법 2: 태그 활용한 버전 관리
1. 운영 배포 시점에 태그 생성
2. `Repository` → `Create tag`
3. 태그명: `v1.0-production-20250806`
4. 해당 태그 기준으로 WAR 빌드

### 2. 배포 전 체크리스트

#### 운영 배포 전 필수 확인사항
- [ ] 클라이언트 승인 여부 확인
- [ ] 테스트 서버 검증 완료
- [ ] 데이터베이스 스크립트 준비
- [ ] 롤백 계획 수립
- [ ] 배포 브랜치(main)에 불필요한 기능 포함 여부 점검

---

## 🔄 일일/주간 워크플로우

### 개발자별 일일 작업 순서

#### 작업 시작 시
1. GitHub Desktop 실행
2. `Fetch origin` 클릭 (최신 상태 확인)
3. develop 브랜치로 전환
4. `Pull origin` 클릭 (최신 내용 동기화)
5. feature 브랜치 생성 또는 기존 브랜치로 전환

#### 작업 완료 시
1. 작업 내용 커밋
2. feature 브랜치에 푸시
3. 필요 시 develop에 병합

### 팀 차원 주간 작업

#### 매주 금요일
1. 완성된 feature 브랜치들을 develop에 병합
2. 테스트 서버 배포
3. 클라이언트 테스트 요청

#### 클라이언트 승인 후
1. 승인된 기능들만 release 브랜치에 포함
2. 운영 서버 배포
3. 배포 태그 생성

---

## ⚠️ 주의사항 및 팁

### Do's (해야 할 것)
- 브랜치명은 의미있게 작성 (`feature/사용자관리`, `hotfix/로그인오류`)
- 커밋 메시지는 구체적으로 작성
- 정기적으로 develop과 동기화
- 배포 전 반드시 테스트 완료 확인

### Don'ts (하지 말 것)
- main 브랜치에서 직접 개발 작업 금지
- 승인되지 않은 기능을 운영에 포함 금지
- 커밋 메시지 대충 작성 금지 ("수정", "작업" 등)
- 충돌 해결 없이 강제 병합 금지

### 긴급 상황 대응
- 운영 오류 발생 시: hotfix 브랜치 생성하여 긴급 수정
- 잘못된 배포 시: 이전 WAR 파일로 즉시 복원
- 심각한 충돌 시: 백업 브랜치에서 작업 재시작

---

## 💡 추가 개선 제안

### 단기 개선안 (1개월 내)
1. 브랜치 전략 표준화 및 팀 교육
2. 커밋 메시지 컨벤션 정립
3. 배포 체크리스트 문서화

### 중장기 개선안 (3-6개월)
1. Maven Profile을 활용한 환경별 설정 분리
2. 배포 스크립트 자동화 (보안 정책 내에서)
3. 코드 리뷰 프로세스 도입

### 보완할 도구들
- SourceTree (GUI Git 클라이언트 대안)
- Maven을 활용한 환경별 빌드 프로파일
- IntelliJ IDEA Community (STS4 대안 검토)

이렇게 단계별로 적용해나가면 소스 혼입 문제와 배포 실수를 크게 줄일 수 있을 거야!

---

안녕! 너희 회사 상황을 보니 정말 많은 개발자들이 겪는 전형적인 문제들이네. 특히 수동 배포와 소스 관리 때문에 고생이 많을 것 같아. 

차근차근 단계별로 해결책을 정리해 줄게!위에 정리한 가이드가 너희 상황에 맞는 실전 해결책이야. 특히 너희가 겪은 문제들을 중심으로 정리했어.

**가장 먼저 적용해야 할 핵심 포인트들:**

1. **브랜치 전략 정립** - main(운영용), develop(테스트용), feature(개발용)로 명확히 분리
2. **운영 반영 프로세스 개선** - 승인된 기능만 선별적으로 main에 포함
3. **GitHub Desktop 실무 활용법** - 브랜치 생성/전환/병합/충돌해결 등

**당장 시작할 수 있는 것들:**

- 기존 코드를 develop 브랜치로 이동
- main 브랜치는 운영 배포용으로만 사용
- 새로운 기능은 무조건 feature 브랜치에서 시작

혹시 구체적으로 어떤 부분부터 시작하고 싶어? 아니면 GitHub Desktop에서 특정 작업 방법이 궁금한 게 있어? 

실제로 적용해보면서 막히는 부분이 있으면 언제든 물어봐!